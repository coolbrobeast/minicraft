<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Minecraft - Fixed Perspectives</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; image-rendering: pixelated; }
        #hud {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center; pointer-events: none; z-index: 10;
        }
        #hearts { display: flex; gap: 4px; margin-bottom: 10px; height: 24px; }
        .heart { width: 24px; height: 24px; }
        #inventory { display: flex; gap: 8px; background: rgba(0,0,0,0.85); padding: 8px; border: 4px solid #333; pointer-events: auto; }
        .slot {
            width: 44px; height: 44px; border: 4px solid #555; display: flex; align-items: center;
            justify-content: center; color: white; font-size: 11px; font-weight: bold; position: relative;
            background: rgba(255,255,255,0.1); text-align: center;
        }
        .slot.active { border-color: #fff; background: rgba(255,255,255,0.2); }
        .count { position: absolute; bottom: 2px; right: 2px; font-size: 12px; text-shadow: 1px 1px #000; pointer-events: none; }
        .label { position: absolute; top: 2px; width: 100%; font-size: 8px; text-transform: uppercase; opacity: 0.7; }

        .overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); border: 4px solid #555; padding: 20px;
            color: white; display: none; z-index: 30; pointer-events: auto;
            min-width: 350px; text-align: center; max-height: 80vh; overflow-y: auto;
        }
        .recipe-list { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 15px; }
        .recipe-item { 
            background: #333; padding: 10px; border: 2px solid #555; 
            cursor: pointer; display: flex; justify-content: space-between; align-items: center;
        }
        .recipe-item:hover { background: #444; border-color: #aaa; }
        
        #boss-bar-container {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 400px; height: 20px; background: rgba(0,0,0,0.5); border: 2px solid #555;
            display: none; z-index: 20;
        }
        #boss-bar-fill { width: 100%; height: 100%; background: #ff00ff; transition: width 0.3s; }
        #boss-name { position: absolute; top: -25px; left: 50%; transform: translateX(-50%); color: #ff00ff; font-weight: bold; text-shadow: 2px 2px #000; }

        #dimension-indicator {
            position: absolute; top: 20px; right: 20px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; pointer-events: none;
        }
        #mode-indicator {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; pointer-events: none;
        }
        #user-info-display {
            position: absolute; top: 60px; left: 20px; color: #aaa; font-size: 12px;
            background: rgba(0,0,0,0.5); padding: 8px; border-radius: 3px; pointer-events: none;
        }
        #instructions {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            color: white; text-align: center; background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100;
        }
        #username-prompt {
            background: #333; border: 4px solid #555; padding: 20px; margin-bottom: 20px;
            display: flex; flex-direction: column; gap: 10px; pointer-events: auto;
        }
        #username-input { padding: 10px; font-size: 18px; border: none; outline: none; background: #222; color: white; border: 2px solid #555; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 5;
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: white; opacity: 0.8; }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }

        #game-state-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: white; text-align: center;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200;
        }
        .death-text { color: #ff4444; font-size: 48px; text-shadow: 4px 4px #440000; margin-bottom: 20px; }
        .win-text { color: #ffff44; font-size: 48px; text-shadow: 4px 4px #444400; margin-bottom: 20px; }
        .retry-btn { 
            background: #444; color: white; border: 4px solid #777; padding: 15px 40px; 
            font-size: 24px; cursor: pointer; transition: background 0.2s;
        }
        .retry-btn:hover { background: #666; }

        #perspective-indicator {
            position: absolute; bottom: 80px; right: 20px; color: white; font-size: 12px;
            background: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="mode-indicator">Survival Mode (M)</div>
    <div id="user-info-display">Connecting to services...</div>
    <div id="dimension-indicator">Dimension: Overworld</div>
    <div id="perspective-indicator">Perspective: 1st Person (F5)</div>
    
    <div id="boss-bar-container">
        <div id="boss-name">Ender Dragon</div>
        <div id="boss-bar-fill"></div>
    </div>

    <div id="hud">
        <div id="hearts"></div>
        <div id="inventory">
            <div class="slot active" data-id="0"><span class="label"></span><span class="count"></span></div>
            <div class="slot" data-id="1"><span class="label"></span><span class="count"></span></div>
            <div class="slot" data-id="2"><span class="label"></span><span class="count"></span></div>
            <div class="slot" data-id="3"><span class="label"></span><span class="count"></span></div>
            <div class="slot" data-id="4"><span class="label"></span><span class="count"></span></div>
            <div class="slot" data-id="5"><span class="label"></span><span class="count"></span></div>
        </div>
    </div>

    <div id="crafting-menu" class="overlay">
        <h2>Crafting / Progression</h2>
        <div class="recipe-list" id="recipes"></div>
        <div id="travel-options" style="margin-top:20px; border-top: 1px solid #555; padding-top:10px;">
            <h3>Dimensional Travel</h3>
            <button onclick="changeDimension('overworld')" style="padding:10px; cursor:pointer;">Overworld</button>
            <button id="btn-nether" onclick="changeDimension('nether')" style="padding:10px; cursor:pointer;">Enter Nether (10 Bricks)</button>
            <button id="btn-end" onclick="changeDimension('end')" style="padding:10px; cursor:pointer;">Enter The End (1 Eye of Ender)</button>
        </div>
        <p style="font-size: 12px; margin-top: 10px;">Press C to close</p>
    </div>

    <div id="game-state-overlay">
        <div id="game-state-content"></div>
        <button class="retry-btn" onclick="respawn()">Respawn / Restart</button>
    </div>

    <div id="instructions">
        <div id="username-prompt">
            <h2 style="margin:0">Character Setup</h2>
            <input type="text" id="username-input" placeholder="Player Name..." maxlength="15">
            <div style="font-size: 12px; margin-top: 5px;">Upload Skin (PNG):</div>
            <input type="file" id="skin-upload" accept="image/png" style="font-size: 12px; color: white;">
            <button id="start-btn" style="padding:10px; cursor:pointer; font-weight:bold; background:#5d994d; border:none; color:white; margin-top: 10px;">JOIN WORLD</button>
        </div>
        <p>W,A,S,D - Move | SPACE - Jump | M - Mode | F5 - Perspective<br>Click - Mine | Right Click - Place | C - Craft</p>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'minecraft-v2';

        let user = null;
        let username = "Player";
        let otherPlayers = new Map();
        let isJoined = false;
        let playerSkinBase64 = null;

        // Perspective Settings: 0 = 1st, 1 = 3rd (Back), 2 = 2nd (Front)
        let perspective = 0;
        let selfModel = null;
        // Logical Player Position (used for physics)
        const playerPos = new THREE.Vector3(0, 30, 0);

        async function initAuth() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (err) {}
        }

        onAuthStateChanged(auth, (u) => {
            user = u;
            if (user) {
                document.getElementById('user-info-display').innerText = `Logged in as: ${username}\nID: ${user.uid.substring(0,8)}`;
                setupMultiplayerListener();
            }
        });

        function setupMultiplayerListener() {
            if (!user) return;
            const playersCol = collection(db, 'artifacts', appId, 'public', 'data', 'players');
            onSnapshot(playersCol, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const id = change.doc.id;
                    if (id === user.uid) return;
                    if (change.type === "removed") removeRemotePlayer(id);
                    else updateRemotePlayer(id, data);
                });
            }, (err) => console.error(err));
            window.addEventListener('beforeunload', () => {
                if (user) deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'players', user.uid));
            });
        }

        function createNameplate(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 64;
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.font = 'bold 32px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.fillText(text, 128, 44);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(1.5, 0.375, 1);
            return sprite;
        }

        function createPlayerModel(skinData = null) {
            const group = new THREE.Group();
            let material;
            if (skinData) {
                const img = new Image();
                img.src = skinData;
                const texture = new THREE.Texture(img);
                img.onload = () => { texture.needsUpdate = true; };
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;
                material = new THREE.MeshLambertMaterial({ map: texture });
            } else {
                material = new THREE.MeshLambertMaterial({ color: 0x3498db });
            }

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.8, 0.4), material);
            group.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshLambertMaterial({ color: 0xffdbac }));
            head.position.y = 1.1;
            group.add(head);
            return group;
        }

        function updateRemotePlayer(id, data) {
            if (data.dimension !== currentDimension) {
                removeRemotePlayer(id);
                return;
            }
            let p = otherPlayers.get(id);
            if (!p) {
                const group = createPlayerModel(data.skin);
                const nameplate = createNameplate(data.username || "Player");
                nameplate.position.y = 1.6;
                group.add(nameplate);
                worlds[currentDimension].group.add(group);
                p = { group: group, name: data.username, skin: data.skin };
                otherPlayers.set(id, p);
            } else if (p.skin !== data.skin) {
                worlds[currentDimension].group.remove(p.group);
                const newGroup = createPlayerModel(data.skin);
                const nameplate = createNameplate(data.username || "Player");
                nameplate.position.y = 1.6;
                newGroup.add(nameplate);
                worlds[currentDimension].group.add(newGroup);
                p.group = newGroup;
                p.skin = data.skin;
            }
            p.group.position.set(data.x, data.y - 1.8, data.z);
            p.group.rotation.y = data.ry;
        }

        function removeRemotePlayer(id) {
            const p = otherPlayers.get(id);
            if (p) {
                Object.values(worlds).forEach(w => w.group.remove(p.group));
                otherPlayers.delete(id);
            }
        }

        async function syncSelf() {
            if (!user || !controls.isLocked) return;
            try {
                const playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'players', user.uid);
                await setDoc(playerRef, {
                    x: playerPos.x,
                    y: playerPos.y,
                    z: playerPos.z,
                    ry: camera.rotation.y,
                    dimension: currentDimension,
                    username: username,
                    skin: playerSkinBase64,
                    lastSeen: Date.now()
                }, { merge: true });
            } catch (e) {}
        }

        function updatePerspective() {
            perspective = (perspective + 1) % 3;
            const labels = ["1st Person", "3rd Person (Back)", "2nd Person (Front)"];
            document.getElementById('perspective-indicator').innerText = `Perspective: ${labels[perspective]} (F5)`;
            
            if (perspective === 0) {
                if (selfModel) selfModel.visible = false;
                document.getElementById('crosshair').style.display = 'block';
            } else {
                if (!selfModel) {
                    selfModel = createPlayerModel(playerSkinBase64);
                    scene.add(selfModel);
                }
                selfModel.visible = true;
                document.getElementById('crosshair').style.display = 'none';
            }
        }

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playNote(freq) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }

        const simplex = new SimplexNoise();
        const blockGeo = new THREE.BoxGeometry(1, 1, 1);
        const textureCache = {};
        window.currentDimension = 'overworld'; 
        const worlds = {
            overworld: { map: new Map(), group: new THREE.Group(), color: 0x87CEEB, mobs: [], size: 40 },
            nether: { map: new Map(), group: new THREE.Group(), color: 0x330000, mobs: [], size: 25 },
            end: { map: new Map(), group: new THREE.Group(), color: 0x050510, mobs: [], size: 20 }
        };

        let isSurvival = true;
        let health = 10;
        let isGameOver = false;
        let selectedSlot = 0;
        let dragon = null;

        const inventory = [
            { type: 'pickaxe', count: 1, isTool: true },
            { type: 'tnt', count: 10 },
            { type: 'redstone', count: 20 },
            { type: 'noteblock', count: 5 },
            { type: 'bricks', count: 5 },
            { type: 'repeater', count: 5 }
        ];

        const recipes = [
            { result: 'tnt', count: 1, ingredients: { stone: 5 } },
            { result: 'noteblock', count: 1, ingredients: { wood: 8 } },
            { result: 'redstone', count: 4, ingredients: { stone: 1 } },
            { result: 'repeater', count: 1, ingredients: { stone: 3, redstone: 2 } },
            { result: 'eye_of_ender', count: 1, ingredients: { pearl: 1, powder: 1 } }
        ];

        function createTex(color, detail, pattern = 'noise') {
            const cacheKey = `${color}-${detail}-${pattern}`;
            if (textureCache[cacheKey]) return textureCache[cacheKey];
            const canvas = document.createElement('canvas');
            canvas.width = 16; canvas.height = 16;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color; 
            ctx.fillRect(0, 0, 16, 16);
            if(pattern === 'noise') {
                for(let i=0; i<40; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? detail : 'rgba(0,0,0,0.1)';
                    ctx.fillRect(Math.floor(Math.random()*16), Math.floor(Math.random()*16), 1, 1);
                }
            } else if(pattern === 'bricks') {
                ctx.fillStyle = detail;
                ctx.fillRect(0, 7, 16, 1); ctx.fillRect(0, 15, 16, 1);
                ctx.fillRect(7, 0, 1, 7); ctx.fillRect(15, 8, 1, 7);
            } else if(pattern === 'tnt') {
                ctx.fillStyle = '#ff0000'; ctx.fillRect(0,0,16,16);
                ctx.fillStyle = '#ffffff'; ctx.fillRect(0,6,16,4);
                ctx.fillStyle = '#000000'; ctx.font = '6px Arial'; ctx.fillText('TNT', 2, 10);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            textureCache[cacheKey] = tex;
            return tex;
        }

        const materials = {
            grass: new THREE.MeshLambertMaterial({ map: createTex('#5d994d', '#4a7a3d') }),
            dirt: new THREE.MeshLambertMaterial({ map: createTex('#8b4513', '#6b3410') }),
            stone: new THREE.MeshLambertMaterial({ map: createTex('#808080', '#696969') }),
            wood: new THREE.MeshLambertMaterial({ map: createTex('#5d4037', '#3e2723') }),
            planks: new THREE.MeshLambertMaterial({ map: createTex('#a67c52', '#8b643d', 'noise') }),
            leaves: new THREE.MeshLambertMaterial({ map: createTex('#2d4c1e', '#1e3314'), transparent: true, opacity: 0.9 }),
            bricks: new THREE.MeshLambertMaterial({ map: createTex('#b05e3c', '#8a4a30', 'bricks') }),
            netherrack: new THREE.MeshLambertMaterial({ map: createTex('#7a1a1a', '#5a1010') }),
            endstone: new THREE.MeshLambertMaterial({ map: createTex('#deeaaf', '#c8d49a') }),
            water: new THREE.MeshLambertMaterial({ color: 0x3f76e4, transparent: true, opacity: 0.6 }),
            tnt: new THREE.MeshLambertMaterial({ map: createTex('#ff0000', '#ffffff', 'tnt') }),
            redstone: new THREE.MeshLambertMaterial({ color: 0xaa0000 }),
            redstone_active: new THREE.MeshLambertMaterial({ color: 0xff0000, emissive: 0xff0000 }),
            noteblock: new THREE.MeshLambertMaterial({ map: createTex('#5d4037', '#ffffff', 'noise') }),
            repeater: new THREE.MeshLambertMaterial({ color: 0x888888 }),
            zombie: new THREE.MeshLambertMaterial({ color: 0x3d6b3d }),
            blaze: new THREE.MeshLambertMaterial({ color: 0xffa500, emissive: 0xff4500 }),
            enderman: new THREE.MeshLambertMaterial({ color: 0x111111, emissive: 0x4b0082 }),
            dragon: new THREE.MeshLambertMaterial({ color: 0x000000, emissive: 0x220022 }),
            pickaxe: { color: '#707070', name: 'Pickaxe' },
            pearl: { color: '#006400', name: 'Pearl' },
            blaze_rod: { color: '#ffd700', name: 'Rod' },
            powder: { color: '#ff8c00', name: 'Powder' },
            eye_of_ender: { color: '#00fa9a', name: 'Eye' }
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(worlds.overworld.color);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        scene.add(sun);

        Object.values(worlds).forEach(w => scene.add(w.group));
        worlds.nether.group.visible = false;
        worlds.end.group.visible = false;

        function updateHUD() {
            const container = document.getElementById('hearts');
            if (!container) return;
            container.innerHTML = '';
            for(let i=0; i<10; i++) {
                const img = document.createElement('img');
                img.className = 'heart';
                img.src = `data:image/svg+xml;base64,${btoa(`<svg width="24" height="24" viewBox="0 0 9 9" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges"><path d="M2 1h1v1h1v1h1V2h1V1h1v1h1v3H7v1H6v1H5v1H4v-1H3v-1H2v-1H1V2h1V1z" fill="${i < health ? '#ff0040' : '#333'}"/></svg>`)}`;
                container.appendChild(img);
            }
            document.querySelectorAll('.slot').forEach((slot, i) => {
                slot.classList.toggle('active', i === selectedSlot);
                const item = inventory[i];
                const countSpan = slot.querySelector('.count');
                const labelSpan = slot.querySelector('.label');
                if (item && (item.count > 0 || item.isTool)) {
                    const mat = materials[item.type];
                    labelSpan.innerText = mat.name || item.type;
                    if (item.isTool || !mat.map) {
                        slot.style.backgroundColor = mat.color || '#555';
                        slot.style.backgroundImage = 'none';
                    } else {
                        slot.style.backgroundImage = `url(${mat.map.image.toDataURL()})`;
                        slot.style.backgroundSize = 'cover';
                        slot.style.backgroundColor = 'transparent';
                    }
                    countSpan.innerText = item.isTool ? '' : item.count;
                } else {
                    slot.style.backgroundImage = 'none';
                    slot.style.backgroundColor = 'rgba(255,255,255,0.1)';
                    countSpan.innerText = '';
                    labelSpan.innerText = '';
                }
            });
            if (isSurvival && health <= 0 && !isGameOver) showGameOver(false);
        }

        function showGameOver(won) {
            isGameOver = true;
            controls.unlock();
            const overlay = document.getElementById('game-state-overlay');
            const content = document.getElementById('game-state-content');
            overlay.style.display = 'flex';
            content.innerHTML = won ? 
                `<div class="win-text">YOU WON!</div><p>The Ender Dragon has been defeated!</p>` : 
                `<div class="death-text">YOU DIED!</div><p>Your journey ends here...</p>`;
        }

        window.respawn = function() {
            health = 10;
            isGameOver = false;
            document.getElementById('game-state-overlay').style.display = 'none';
            changeDimension('overworld');
            updateHUD();
            controls.lock();
        };

        function addBlock(dim, x, y, z, type) {
            const worldObj = worlds[dim];
            const key = `${x},${y},${z}`;
            if (worldObj.map.has(key)) return;
            const mesh = new THREE.Mesh(blockGeo, materials[type]);
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            if (type === 'redstone') { mesh.scale.set(0.8, 0.1, 0.8); mesh.position.y = y + 0.05; }
            else if (type === 'repeater') { mesh.scale.set(0.9, 0.2, 0.9); mesh.position.y = y + 0.1; }
            worldObj.group.add(mesh);
            worldObj.map.set(key, { mesh, type });
        }

        function spawnMob(dim, type, x, y, z) {
            let mesh;
            if (type === 'dragon') {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 8), materials.dragon);
                mesh.position.set(x, 40, z);
                dragon = { mesh, health: 100, maxHealth: 100, angle: 0 };
            } else {
                let height = (type === 'enderman') ? 2.8 : 1.8;
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, height, 0.6), materials[type]);
                mesh.position.set(x, y, z);
            }
            worlds[dim].group.add(mesh);
            worlds[dim].mobs.push({ mesh, type, health: type === 'enderman' ? 20 : 10 });
        }

        window.changeDimension = function(newDim) {
            const hasBricks = inventory.reduce((s,i) => i.type === 'bricks' ? s + i.count : s, 0);
            const hasEyes = inventory.reduce((s,i) => i.type === 'eye_of_ender' ? s + i.count : s, 0);
            if (newDim === 'nether' && hasBricks < 10 && currentDimension === 'overworld' && isSurvival) return;
            if (newDim === 'end' && hasEyes < 1 && currentDimension !== 'end' && isSurvival) return;
            otherPlayers.forEach((p, id) => removeRemotePlayer(id));
            worlds[currentDimension].group.visible = false;
            currentDimension = newDim;
            worlds[currentDimension].group.visible = true;
            scene.background.set(worlds[currentDimension].color);
            document.getElementById('dimension-indicator').innerText = "Dimension: " + newDim.toUpperCase();
            document.getElementById('boss-bar-container').style.display = (newDim === 'end' && dragon) ? 'block' : 'none';
            let spawnY = 40;
            const worldMap = worlds[currentDimension].map;
            for(let y = 60; y >= 0; y--) { if(worldMap.has(`0,${y},0`)) { spawnY = y + 2; break; } }
            playerPos.set(0.5, spawnY, 0.5);
            velocity.set(0, 0, 0);
            syncSelf();
        };

        function generateWorlds() {
            const size = worlds.overworld.size;
            for(let x = -size; x < size; x++) {
                for(let z = -size; z < size; z++) {
                    const h = Math.floor((simplex.noise2D(x/60, z/60) + simplex.noise2D(x/15, z/15)*0.3) * 12 + 8);
                    for(let y = 0; y <= Math.max(h, 5); y++) {
                        if (y <= h) addBlock('overworld', x, y, z, y === h ? 'grass' : (y < h - 2 ? 'stone' : 'dirt'));
                        else if (y <= 5) addBlock('overworld', x, y, z, 'water');
                    }
                }
            }
            spawnMob('end', 'dragon', 0, 45, 0);
        }
        generateWorlds();

        const controls = new THREE.PointerLockControls(camera, document.body);
        const instructions = document.getElementById('instructions');
        const startBtn = document.getElementById('start-btn');
        const usernameInput = document.getElementById('username-input');
        const skinUpload = document.getElementById('skin-upload');

        skinUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => { playerSkinBase64 = ev.target.result; };
                reader.readAsDataURL(file);
            }
        });

        startBtn.addEventListener('click', async () => {
            if (usernameInput.value.trim().length > 0) username = usernameInput.value.trim();
            isJoined = true;
            await initAuth();
            if(!isGameOver) { audioCtx.resume(); controls.lock(); }
        });

        controls.addEventListener('lock', () => instructions.style.display = 'none');
        
        const keys = {};
        window.addEventListener('keydown', e => {
            if(isGameOver || (!isJoined && document.activeElement === usernameInput)) return;
            if(!isJoined) return; 
            keys[e.code] = true;
            if(e.code === 'KeyM') { isSurvival = !isSurvival; document.getElementById('mode-indicator').innerText = isSurvival ? "Survival Mode (M)" : "Creative Mode (M)"; }
            if(e.code === 'KeyC') { if(controls.isLocked) controls.unlock(); else controls.lock(); document.getElementById('crafting-menu').style.display = controls.isLocked ? 'none' : 'block'; }
            if(e.code === 'F5') { e.preventDefault(); updatePerspective(); }
            if(e.code.startsWith('Digit')) { selectedSlot = parseInt(e.key) - 1; updateHUD(); }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        const raycaster = new THREE.Raycaster();
        window.addEventListener('mousedown', e => {
            if(!controls.isLocked || isGameOver || !isJoined) return;
            raycaster.setFromCamera({x:0, y:0}, camera);
            const currentWorld = worlds[currentDimension];
            const hits = raycaster.intersectObjects(currentWorld.group.children.filter(c => c.geometry && c.geometry.type === "BoxGeometry" && c !== dragon?.mesh));
            if(hits.length > 0 && hits[0].distance < 7) {
                const hit = hits[0];
                const p = hit.object.position;
                const bx = Math.floor(p.x), by = Math.floor(p.y), bz = Math.floor(p.z);
                const key = `${bx},${by},${bz}`;
                if(e.button === 0) {
                    currentWorld.group.remove(hit.object);
                    currentWorld.map.delete(key);
                } else if(e.button === 2) {
                    const item = inventory[selectedSlot];
                    if (item && item.count > 0 && !item.isTool) {
                        const np = hit.object.position.clone().add(hit.face.normal);
                        addBlock(currentDimension, Math.floor(np.x), Math.floor(np.y), Math.floor(np.z), item.type);
                        if (isSurvival) item.count--;
                        updateHUD();
                    }
                }
            }
        });

        const velocity = new THREE.Vector3();
        let lastTime = performance.now();
        let lastSync = 0;

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            if (controls.isLocked && !isGameOver && isJoined) {
                const currentWorld = worlds[currentDimension];
                if (isSurvival) velocity.y -= 25 * delta;
                
                const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
                const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();
                const move = new THREE.Vector3();
                if(keys['KeyW']) move.add(dir); if(keys['KeyS']) move.sub(dir);
                if(keys['KeyA']) move.add(side); if(keys['KeyD']) move.sub(side);
                move.normalize().multiplyScalar(8 * delta);
                
                const check = (pos) => {
                    const b = currentWorld.map.get(`${Math.floor(pos.x)},${Math.floor(pos.y - 1.5)},${Math.floor(pos.z)}`);
                    return b && b.type !== 'water';
                };

                const old = playerPos.clone();
                playerPos.x += move.x; if(isSurvival && check(playerPos)) playerPos.x = old.x;
                playerPos.z += move.z; if(isSurvival && check(playerPos)) playerPos.z = old.z;
                playerPos.y += velocity.y * delta;
                if(isSurvival && check(playerPos)) { playerPos.y = old.y; if(velocity.y < 0 && keys['Space']) velocity.y = 10; else velocity.y = 0; }

                // Sync physical camera position to logical player position head height
                camera.position.copy(playerPos);
                const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);

                if (perspective === 0) {
                    // Normal 1st Person: Camera is at logical position
                    if (selfModel) selfModel.visible = false;
                } else {
                    // Offset views: Place selfModel at logical position
                    if (selfModel) {
                        selfModel.visible = true;
                        selfModel.position.copy(playerPos).add(new THREE.Vector3(0, -1.8, 0));
                        selfModel.rotation.y = camera.rotation.y;
                    }
                    if (perspective === 1) { // 3rd Person Back
                        camera.position.sub(camDir.clone().multiplyScalar(3.5)).add(new THREE.Vector3(0, 0.5, 0));
                    } else if (perspective === 2) { // 2nd Person Front
                        camera.position.add(camDir.clone().multiplyScalar(3.5)).add(new THREE.Vector3(0, 0.5, 0));
                        camera.lookAt(playerPos.clone().add(new THREE.Vector3(0, -0.2, 0)));
                    }
                }

                if (currentDimension === 'end' && dragon) {
                    dragon.angle += delta * 0.4;
                    dragon.mesh.position.lerp(new THREE.Vector3(Math.cos(dragon.angle)*12, 25 + Math.sin(dragon.angle*1.5)*8, Math.sin(dragon.angle)*12), 0.05);
                    dragon.mesh.lookAt(playerPos);
                }
                if (time - lastSync > 100) { syncSelf(); lastSync = time; }
            }
            renderer.render(scene, camera);
        }
        animate();
        updateHUD();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
